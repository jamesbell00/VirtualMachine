import slu.rvm.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.io.PrintWriter;
import java.io.File;
import java.io.FileNotFoundException;

public class VirtualMachine implements IVirtualMachine {

	/* 16-bit RISC Virtual Machine (RVM)
	 * 
	 * - The CPU can address 256 words of main memory locations from 0x00 to 0xFF. Each memory location has 8 bits
	 * - Memory address 0xFF is reserved for the VM, thus the address space available for user-programs has 255 memory locations 
	 * - The CPU has 16 registers, numbered from r0 to r15. Registers store a 16-bit word, the same as memory words, the value of register r0 is always 0 
	 * - The program counter (PC) is a special register that points to the next instruction to be executed. It has 8 bits, so it can address up to 256 memory addresses
	 * - The PC stores the memory address of the next instruction to execute
	 * - The Instruction Register (IR) is a special register that stores the instruction after the fetch cycle. This instruction is decoded before execution
	 * - The CPU translates logical addresses into physical addresses during the fetch cycle
	 * - The CPU checks that the physical address generated by an instruction is in the limits of the virtual address space
	 *   of the process, otherwise it throws an exception due to an invalid memory address
	 * - When the CPU runs more than 1,000 instructions in a single burst, it throws the exception due to an infinite loop
	 * - The RISC VM supports two different page sizes, 16 and 32 memory words, that are allocated in the address space 0x00 to 0xFE  
	 * - The code of a program uses logical addresses starting at 0x00, and the control flow instructions use relative addresses 
	 * - The code of a program is loaded into its virtual address space, the page size is assigned using the Best-fit strategy 
 	 * - The process table can hold up to 12 processes in memory
	 * 
	 */
	
	private final static int MAX_PROCESSES        = 12;
	private final static int PAGE_SIZE_16         = 0x10; // 16 memory words
	private final static int PAGE_SIZE_32         = 0x20; // 32 memory words
	private static final int MEMORY_BASE_ADDRESS  = 0x00; // RAM base address 
	private static final int MEMORY_LIMIT_ADDRESS = 0xFE; // RAM limit address, address 0xFF is reserved for I/O

	private int maxProcesses;
	private int currentMemoryBaseAddress;
	private Process [] processTable;
	private ICentralProcessingUnit core;
	
	private PrintWriter logFile;
	
	public VirtualMachine(String name) throws FileNotFoundException {
		this(name, Integer.MAX_VALUE);
	}
	
	public VirtualMachine(String name, int quantum) throws FileNotFoundException {
		this.processTable = new Process[MAX_PROCESSES];
		this.currentMemoryBaseAddress = MEMORY_BASE_ADDRESS;
		this.maxProcesses = -1;
		this.logFile = new PrintWriter(new File(name + ".txt"));
		this.core = new CentralProcessingUnit(this.logFile, quantum);
	}

	@Override
	public EProcessState getProcessState(int process) {
		return this.processTable[process].getState();
	}

	@Override
	public int getQuantum() {
		return this.core.getQuantum();
	}

	@Override
	public void setQuantum(int quantum) {
		this.core.setQuantum(quantum);
	}
	
	@Override
	public int load(String fileName, String name) throws Exception {
		// load the source program from disk into an ArrayList

		File inputFile = new File(fileName);

		if (!inputFile.exists()) 
			throw new Exception("File '" + fileName + "' not found!");			

    	Scanner sourceFile = new Scanner(inputFile);

		List<String> program = new ArrayList<String>();
		
        while (sourceFile.hasNext()) {
        	String instruction = sourceFile.nextLine();
        	
			program.add(instruction);
        }
          
        sourceFile.close();
        
    	// creates a new process in the process table, the process is defined by its id, name, state, virtual address space and process control block (PCB)
		// the VM supports two page sizes (16 and 32 memory words), the page size is assigned using the Best-fit strategy
		System.out.println("Program size: "+program.size());
		int programSize = program.size();
		int pageSize = (program.size() < PAGE_SIZE_16) ? PAGE_SIZE_16 : PAGE_SIZE_32; 
		
		// check if there is free memory to allocate a new page
		
		if (this.currentMemoryBaseAddress + pageSize > MEMORY_LIMIT_ADDRESS)
			throw new Exception("RISC Virtual Machine Fault: Run out of memory");
		
		// check if there is free memory in the process table and the process can be created
		
		if (this.maxProcesses > MAX_PROCESSES - 1)
			throw new Exception("RISC Virtual Machine Fault: Process table run out of memory");
		
		// create a new process and its process table
		
		this.maxProcesses++;

		this.processTable[this.maxProcesses] = new Process(this.maxProcesses, name, new AddressSpace(this.currentMemoryBaseAddress, pageSize));
		
		this.processTable[this.maxProcesses].setProcessSize(programSize);
		
		// update the base memory address is increased in page size memory words
		
		this.currentMemoryBaseAddress = this.currentMemoryBaseAddress + pageSize;

		int baseAddress = processTable[this.maxProcesses].getBaseAddress();

		this.logFile.println("Program " + name + "\n");

		int logicalAddress = 0;
		
		for (String instruction : program) {
			this.core.setMemory(baseAddress, Functions.hex2dec(instruction.substring(2)));
			
			this.logFile.println(Functions.dec2hex(logicalAddress, 2) + " " + Functions.hex2Assembly(this.core.getMemory(baseAddress)));

			baseAddress++;
			logicalAddress++;
		}
			
		this.logFile.println("");
		
		return this.maxProcesses;
	}
		
	@Override
	public void run(int process) throws Exception {
		try {
			this.logFile.println("Executing process " +  this.processTable[process].getName() + ", state is " + this.processTable[process].getState() + ", page size " + (this.processTable[process].getLimitAddress() - this.processTable[process].getBaseAddress() + 1) + ", address space " + Functions.dec2hex(this.processTable[process].getBaseAddress(), 2) + " to " + Functions.dec2hex(this.processTable[process].getLimitAddress(), 2) + "\n");
			
			// restore the process control block (PCB) before execution, the PCB contains the CPU registers and PC
			
			// if the process state is NEW, the program counter (PC) in the PCB holds the base address of the process virtual address space
			// if the process state is READY, the PCB must be restored before the CPU resumes execution, the PCB holds the state of the CPU registers and the PC when the process was paused
			
			// get the Process Control Block to restore the values of the CPU registers and PC
				
			IProcessControlBlock pcb = this.processTable[process].getPCB();
				
			this.core.setRegisters(pcb.getRegisters());
			this.core.setPC(pcb.getPC());
						
			// start or resume process execution, run(process) returns the process state: TERMINATED or READY
			// the process control block (PCB) is saved when state is READY, since the process needs more runs to terminate
			
			if (this.core.run(this.processTable[process]) == EProcessState.TERMINATED) {
					
				this.processTable[process].setState(EProcessState.TERMINATED);
				this.logFile.println("\n" + this.processTable[process].getName() + " state is " + this.processTable[process].getState() + ", output is " + this.core.getMemory(0xFF) + "\n");
				
			} else {
				
				this.processTable[process].setPCB(new ProcessControlBlock(this.core.getRegisters() , this.core.getPC()));
				this.processTable[process].setState(EProcessState.READY);
				
				this.logFile.println("\n" + this.processTable[process].getName() + " state is " + this.processTable[process].getState() + "\n");
			}	
				
			// to do:
			//
			// if the CPU returns EProcessState.TERMINATED set the process state to TERMINATED and print out the outcome stored at memory address 0xFF
			// else set the process state to READY and save the CPU registers and PC in the process control block (PCB)

			// ---------------------------------------------------------------------------------------------------------
			
		} catch (Exception e) {
			
			// stop machine execution
			
			halt();
			
			// throw an exception with the error message thrown by the CPU
			
			throw new Exception("RISC Virtual Machine Fault: " + e.getMessage());
		}	
	}	
	
	@Override
	public void dump() {
		this.core.dump();
	}
		
	@Override
	public void halt() {
		this.logFile.close();
	}

	public Process [] getProcessTable(){
		return this.processTable;
	}
}